---
section: os
title: "Пользователи и их права доступа"
---


### Зачем нужно разделение доступа?

Современные операционные системы рассчитаны на использование многими пользователями одновременно. Раньше такое разделение использовалось когда компьютеры были слишком дорогими, чтобы обеспечивать ими всех работников и несколько человек могли по сети подключиться к одной рабочей станции, чтобы работать с ней. 

При работе нескольких пользователей за одной машиной необходимо разделить их полномочия. Во-первых, пользователи не должны иметь право вмешиваться в работу системы в целом. Например, если один пользователь захочет удалить установленную в системе программу, это может затронуть работу других пользователей, которые эту программу используют. Во-вторых, пользователи должны сами решать, показывать ли свои файлы и папки другим пользователям. 

Естественно, должны существовать пользователи с расширенным набором полномочий, которые могут осуществлять обслуживание системы в целом. Обычно это системные администраторы, которые ответственны за техническое состояние системы. Обычно они же управляют полномочиями пользователей: определяют, что могут, а чего не могут делать рядовые пользователи.

Сейчас, в эру персональных компьютеров когда за Вашим личным компьютером вряд ли работает много малознакомых человек, многопользовательская работа используется для двух основных сценариев:

1. Если мы говорим о пользовательских устройствах, то часто пользователи используются для разделения доступа между приложениями. Например, в ОС Android для каждого установленного приложения регистрируется новый пользователь. Таким образом, одно приложение не может вмешаться в работу другого и в работу системы в целом.
2. На серверных компьютерах все еще зачастую работают несколько человек, как системных администраторов, так и неограниченный круг пользователей, которые могут подключаться к серверу по сети и иметь доступ к некоторым данным и сервисам этого сервера. Даже на ваш персональный компьютер могут подключиться пользователи и процессы по сети и им необходимо как-то ограничить возможность действий в операционной системе.

В любом случае, речь идет о разграничении доступа пользователей к ресурсам операционной системы. Под ресурсом здесь понимается любая информация, аппаратные компоненты, программы, то есть все, чем можно воспользоваться при работе за компьютером. В операционной системе Linux любые информационные ресурсы представляются в виде файла. Это позволяет иметь один механизм разделению доступа - по файлам, вместо того, чтобы отдельно ограничивать доступ к аппаратным компонентам, сети, программам и так далее. 

Любой пользователь компьютера в такой системе имеет определенные права - что-то он может делать, а что-то сама операционная система ему запретит. В Linux, так как все представляется в виде файла это выражается в том, что к каким-то файлам у пользователя есть доступ, а к каким-то нет, или он ограничен. Причем при проектировании операционных систем гораздо безопаснее и надежнее исходить их принципа минимальных прав - это когда пользователю разрешается только то, что ему необходимо делать, а все остальное - запрещается. Другими словами, все, что не разрешено явно и специально - запрещено по умолчанию. При таком подходе пользователь не сможет своими действиями нанести вред всей системе, умышленно или случайно.

{% capture notice-2 %}
Выводы:
1. Современные компьютеры могут использоваться несколькими пользователями одновременно.
2. Поэтому должно быть разделение и ограничение доступа к ресурсам.
3. Ресурсы - это файлы, устройства, сеть. В Linux - это все файлы.
5. Пользователи могут применяться для разделения доступа между приложениями.
6. Каждый пользователь имеет свои полномочия в системе - права доступа.
7. Необходимо придерживаться принципа минимальных прав.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Что такое пользователь?

![Пользователь](/assets/images/os_text/os13-0.png "Пользователь"){: .align-center style="width: 800px;"}
{: style="text-align: center; font-size:0.7em;"}

Для того, чтобы система разделения прав доступа работала, операционная система должна знать две вещи: во-первых, какие пользователи вообще существуют и каким из них является данный пользователь. Первое - это регистрация, а второе - авторизация. В первую очередь, операционная система должна хранить информацию о том, какие пользователи ей знакомы, и какими правами обладает каждый из них. Запись о пользователе в операционной системе называется учетной записью. При установке системы создается учетная запись администратора системы, могут быть созданы запись других пользователей. Администратор может потом создавать, удалять или редактировать учетные записи пользователей.

Для начала работы с операционной системой человек должен пройти процедуру авторизации - сопоставления пользователя одной из учетных записей, хранящихся в системе. 

Авторизация обычно построена на вводе в систему одного из возможных секретов:
1. То, что пользователь знает - авторизация по паролю или ключевой фразе. Это технически самый простой вид авторизации до сих пор широко распространен.
2. То, что пользователь имеет - физический ключ, содержащий электронный криптографический сертификат. Это развитие предыдущего способа, когда конкретный секрет скрыт для безопасности от пользователя и воплощен в какой-то физической форме.
3. То, чем пользователь является - биометрическая аутентификация. Еще недавно этот способ был очень дорогим из-за нераспространенности специализированного оборудования. Сейчас он используется все чаще, так как биометрические датчики встроены во многие смартфоны. Очень часто он используется в сочетании с другими способами (двухфакторная аутентификация).

В настоящее время наиболее распространена авторизация по паролю - это самый технически простой и потенциально надежный способ. В последнее время все больше распространяются способы биометрической авторизации, более сложные способы - например, двухфакторная аутентификация которая основана на авторизации на другом доверенном устройстве. Но в любом случае, авторизация - это доказательство, что вы действительно являетесь тем пользователем, который заявляется. В случае авторизации по паролю пользователь должен ввести логин (имя пользователя) и пароль. Если пароль не соответствует тому, что содержится в учетной запись данного пользователя в конфигурации операционной системы, то она откажет пользователю в работе. 

Если же авторизация проша успешно, операционная система запускает программу-оболочку. Это может быть текстовый командный интерпретатор, либо графический оконный менеджер, в зависимости от настроек и комплекта поставки системы. Но в любом случае, далее приводится в действие важный принцип, без которого невозможно надежное функционирование операционных систем и разделения доступа - все действия, которые пользователь выполняет, операционная система отслеживает и проверяет на права доступа. То есть пользователь не сможет получить доступ ни к чему, чтобы ему не было разрешено операционной системой. Более того, любая программа, команда, процесс, который запускает этот пользователь, будет работать с его правами. 

Эта система работает за счет двух фактов: во-первых, пользователь не может получить доступ ни к каким ресурсам компьютера напрямую, только через операционную систему. Например, пользователь (или, что то же самое, программа, запущенная пользователем) не может напрямую открыть файл. Пользователь может лишь попросить операционную систему открыть файл и дать ему содержимое этого файла. Обычно, это происходит быстро и прозрачно, так что создается впечатление, что сам пользователь открывает файл. И во-вторых, система проверки прав доступа "зашита" в сам фундамент операционной системы, в ее ядро. Это не позволяет обойти систему прав доступа. Каждый раз когда нужно обратиться к какому-то компьютерному ресурсу, пользователь вынужден просить об этом операционную систему, а она, в свою очередь, каждый раз проверяет, что за пользователь пытается выполнить это действие и имеет ли он на это право.

Кстати, мы обычно подразумеваем, что пользователь - это человек, который работает за компьютером. Но с точки зрения операционной системы пользователь - это учетная запись, обладающая определенными правами. Человек может авторизоваться как определенный пользователь. А потом, в процессе работы, он может авторизоваться как другой пользователь, то есть сменить учетную запись. Так что лучше считать, что пользователь - это определенная роль при работе с операционной системой. Не обязательно создавать строго по одному пользователю на каждого человека, который работает за компьютером. Иногда удобнее создать пользователя в определенными правами для выполнения конкретных действий, или для работы с определенной программой. Такие пользователи иногда называются служебными. И в любой операционной системе служебных пользователей гораздо больше, чем "реальных".

{% capture notice-2 %}
Выводы:
1. Пользователь для ОС - это учетная запись с именем и способом авторизации.
1. Первоначальная регистрация пользователей происходит при установке операционной системы.
2. Обычно применяется авторизацию по паролю.
3. Для начала работы в системе необходимо залогиниться - пройти авторизацию.
4. Все процессы, которые запускает пользователь выполняются от его имени и с его правами.
5. Система авторизации и разграничения пользователей встроена в само ядро операционной системы.
1. Существуют служебные пользователи - они не люди, а роли при работе, которые нужны для удобства.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Где хранится информация о пользователях?

![Файл /etc/passwd](/assets/images/os_text/os13-1.png "Файл /etc/passwd"){: .align-center style="width: 800px;"}
{: style="text-align: center; font-size:0.7em;"}

В любой операционной системе хранится информация о том, какие пользователи в ней зарегистрированы и могут авторизоваться для работы с ней. В Linux эта информация хранится в файле /etc/passwd. Это простой текстовый файл, как и большинство других конфигурационных файлов Linux. Его можно открыть и отредактировать любым текстовым редактором или командами работы с текстом терминала. Этот файл доступен для просмотра любому авторизованному пользователю, но редактировать его может только администратор системы.

Файл /etc/passwd представляет собой табличную структуру - каждая строка в нем соответствует одному пользователю, а в строке содержатся несколько полей, значения которых разделяются двоеточиями. Это типичная структура конфигурационного файла Linux. Надо отметить, что этот файл - это не просто отображение информации о пользователях, он и представляет собой настройку операционной системы. Она сама берет информацию о своих пользователях из этого файла. Поэтому, если этот файл отредактировать, например, добавить в него новую строку, это будет эквивалентно регистрации нового пользователя.

Любой пользователь Linux должен иметь имя - строку, которая однозначно характеризует пользователя (то есть не повторяется) и отображается во всех сообщениях системы. Имя пользователя состоит из строчных латинских букв и может содержать знаки подчеркивания. Имя пользователя так же указывается при авторизации пользователей в системе. 

Кроме символьного имени, каждому пользователю автоматически присваивается численный идентификатор. Операционной системе проще работать с числами, чем со строками, поэтому этот идентификатор, называемый UID (user identifier), используется внутри системы. Например, именно он отслеживается у всех запущенных процессов. Обычно, в современных дистрибутивах Linux идентификаторы пользователей, которые были вручную созданы при установке или настройке системы начинаются с 1000. Номера меньше 1000 зарезервированы для служебных пользователей, которые создаются автоматически разными программами. 

Кроме имени и идентификатора для авторизации пользователя нужен пароль. Раньше пароль указывался тут же, в файле /etc/passwd, вместе со всей остальной информацией о пользователе. Но по соображениям удобства, нужно, чтобы этот файл был доступен на чтение всем пользователям системы. Это нужно для организации процесса аутентификации. А если любой пользователь может прочитать этот файл, значит в нем нельзя хранить пароли. Поэтому сейчас вы не увидите паролей в файле /etc/passwd, на их месте стоит символ "х". Сами пароли (а вернее их хеши) хранятся в другом файле - /etc/shadow, который доступен для чтения только администратору системы.

Еще в файле /etc/passwd для каждого пользователя указывается адрес домашней папки. Этот адрес подставляется вместо символа ~ в путях, а также в некоторых других сокращениях команд терминала. Домашняя папка пользователя предназначена для хранения файлов этого пользователя. У любого пользователя, естественно, есть полный доступ к этой папке. То есть он может создавать, удалять там папки, файлы, организовывать любой иерархию директорий. А вот к системным папкам у пользователя может быть только ограниченный доступ - на чтения, или вообще никакого. Так же в домашней папке пользователя могут храниться конфигурационные файлы, содержащие настройки системы или отдельных программ, относящиеся только к этому пользователю.

Обычно, при регистрации нового пользователя, его домашняя папка создается автоматически в папке /home/. И называется домашняя папка так же, как и сам пользователь. То есть у пользователя user домашняя папка по умолчанию будет /home/user. Но это можно изменить в конфигурационном файле или в команде создания пользователя. Обратите внимание, что сама папка /home/ не является домашней, и принадлежит администратору. То есть сам пользователь не сможет иметь к ней полного доступа.

Кстати, служебным пользователям, которые создаются автоматически и не соответствуют живому человеку, работающему за компьютером, домашние папки обычно не нужны. В таком случае, создание домашней папки можно пропустить, а в файле /etc/passwd будет просто пропуск.

И в последнем поле файла /etc/passwd хранится команда, которая автоматически запускается после авторизации данного пользователя в систему. Обычно, это интерпретатор командной строки /bin/bash. Именно из-за этого поведения после авторизации мы обычно видим интерфейс командной строки. Но имейте в виду, что у разных пользователей может быть установлены разные командные интерпретаторы по умолчанию. Bash - это всего лишь самый распространенный из них. 

Еще при создании пользователя можно справочно установить некоторые необязательные поля - полное имя, номер кабинета, телефона. В настоящее время они практически никогда не используются и остаются пустыми. 

{% capture notice-2 %}
Выводы:
1. В Linux информация о всех пользователях хранится в файле /etc/passwd.
2. Изначально он хранил пароли, но их давно оттуда убрали для безопасности и удобства.
3. У каждого пользователя есть идентификатор - UID.
4. У каждого пользователя есть символьное имя - логин.
5. У пользователя может быть задан пароль на вход в систему.
6. У пользователя может быть домашняя папка, интерпретатор по умолчанию.
7. Еще можно задать много дополнительной информации - номер кабинета, телефона.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Зачем нужны группы?

![Файл /etc/group](/assets/images/os_text/os13-2.png "Файл /etc/group"){: .align-center style="width: 800px;"}
{: style="text-align: center; font-size:0.7em;"}

С помощью учетных записей пользователей можно организовать простое разделение доступа, но этот механизм имеет свои ограничения. Что делать, если нужно разрешить доступ к данному файлу сразу нескольким пользователям, но не другим? Для этого в операционных системах существуют группы. Группа - это просто некоторое множество зарегистрированных пользователей, права для которых можно задавать для всей группы. Это очень удобно для более сложного управления правами. С одной стороны, у нас есть множество файлов (как мы помним, в UNIX все организовано так, что любые действия с системой - это взаимодействия с определенными файлами), с другой - множество пользователей. В таком случае взаимодействие многие-ко -многим очень неудобно. Введение групп пользователей позволяет решить эту проблему.

Читатель может спросить: а что делать, если необходимо дать определенные права нескольким группам? Не оказываемся ли мы в точно таком же затруднении, как с пользователями? На самом деле нет, потому что достаточно создать новую группу, в которую входят пользователи из всех нужных групп. Поэтому такой промежуточный механизм действительно решает проблему множественных прав.

Вся необходимая системе информация о группах хранится в файле _/etc/group_. Вот фрагмент содержания такого файла:

```
root:x:0:
daemon:x:1:
adm:x:4:syslog,user
user:x:1000:user
sambashare:x:133:koroteev
vboxusers:x:134:user
test:x:1001:
```

Структура этого файла очень проста. Каждая строка соответствует зарегистрированной группе. В строчке указывается 4 значения, разделенные символом двоеточия. После имени идет пароль группы. Этот механизм когда-то использовался для защиты групповых действий паролем, но сейчас у всех групп пароль не ставят, указывая символ _x_. Затем идет численный идентификатор группы. Группы нумеруются с нуля. Обычно, системные группы, которые создаются при установке ОС или системными программами и необходимы для ее функционирования имеют номера до 999. Группы, которые создаются пользователями или пользовательскими программами имеют номера с 100 и выше. После третьего двоеточия указывается список имен пользователей-членов группы через запятую.

В примере выше мы видим, например, группу _root_. Эта служебная группа используется как группа по умолчанию для одноименного пользователя _root_. Именно группу _root_ как владельца получают файлы, созданные из-под администраторской учетки. Как видно, не во всех группах могут быть члены, некоторые группы создаются "на всякий случай", и явлются пустыми.

Примечательная группа с идентификатором 1000 и именем _user_, таким же, как и имя пользователя. Дело в том, что при создании пользователя обычно автоматически создается группа с таким же именем и это пользователь туда добавляется. Это так называемая "группа по умолчанию" для каждого пользователя. Она нужна для задания группы-владельца файлов, создаваемых пользоватем.

Еще одна группа, которая фигурирует в примере - _vboxusers_. Ее членам разрешается доступ к механизмам виртуализации и виртуальным машинам. Поэтому добавление пользователя в эту группу эквивалентно разрешению ему производить соответствующие действия. Примерно также работает системная группа _sudo_ или _sudoers_ (в зависимости от дистрибутива). Членам этой группы разрешено пользоваться программой _sudo_, которая позволяет выполнить действия от имени пользователя _root_. Поэтому если вы хотите разрешить пользователю это действие, достаточно добавить его в эту группу. 

На практике механизм групп часто используется  самой системой и системными программами. Но иногда его заменяет другой механизм - сами пользователи. Вместо того, чтобы создавать специальную группу, которой разрешены определенные действия, можно создать одного специального пользователя, придать ему все необходимые права, и при необходимости, переключаться в учетную запись этого пользователя, либо запускать программы из-под учетки этого пользователя. Так работают, например, сетевые службы и системы управления базами данных. Но такая работа имеет свои недостатки и не всегда может заменить механизм групп. Поэтому группы все еще используются, хоть и не так часто.

{% capture notice-2 %}
Выводы:
1. Группы были придуманы для удобства назначения прав доступа нескольким пользователям.
5. Информация о группах хранится в файле /etc/group.
4. Любой пользователь может быть членом одной или нескольких групп. 
6. При создании пользователя автоматически создается группа с таким же именем.
2. В настоящее время группы используются не очень часто.
3. Гораздо чаще создается специальный пользователь с нужными правами.
7. Существует группа sudoers или sudousers - только ее члены могут использовать sudo.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Что такое суперпользователь?

![Файл /etc/group](/assets/images/os_text/os13-4.png "Файл /etc/group"){: .align-center style="width: 800px;"}
{: style="text-align: center; font-size:0.7em;"}

Как мы говорили, пользователи в операционной системе нужны для разделения доступа - чтобы один пользователь в своей работе не мог никак нарушить работу другого пользователя. Поэтому учетные записи "обычных" пользователей в многопользовательских операционных системах всегда сильно ограничены в том, что они могут делать. Естественно, они не могут иметь доступ к файлам других пользователей (если те не разрешают это явно). Но еще они не могут выполнять действия, имеющие глобально влияние на всю операционную систему. Например, пользователи не должны менять общесистемные настройки, удалять общее программное обеспечение и так далее. 

Но, конечно, иногда такие общесистемные действия приходится кому-то выполнять. Раньше, когда компьютеры были большими, корпоративными и действительно многопользовательскими, такую работу выполняли специально назначенные системные администраторы, которые по службе отвечали за настройку и поддержание работы системы. Сейчас зачастую компьютеры эксплуатируются в индивидуальном режиме, но название "администратор" для обозначения пользователя с расширенными правами осталось.

В UNIX-системах эта проблема решается простым и кардинальным способом. Существует специальный, особый пользователь _root_, которому в системе разрешено вообще все. В других операционных системах могут быть пользователи с разными уровнями доступа, здесь же все просто - либо обычный, ограниченный пользователь, либо _root_ - суперпользователь. Этот особый пользователь всегда называется именно _root_, имеет идентификатор пользователя 0, всегда создается при установке системы. Удалить или переименовать его нельзя, это глубоко зашито в логику работы самой операционной системы. 

Суперпользователь, кстати - вполне официальное название (superuser).

Пользователь _root_ нужен именно для выполнения операций, затрагивающих систему в целом - установка и удаление программ, редактирование общесистемных настроек, управление пользователями (создание, удаление), управление системными службами и так далее. Это пользователь настолько не ограничен, что несовсем правильно даже говорить, что ему все разрешено. При совершении действий под учетной записью _root_ права доступа даже не проверяются.

{% capture notice %}
Это в частности значит, что _root_ даже сам не может что-то себе запретить. Попробуйте на досуге создать файл (под любым пользователем, даже под рутом) и запретить всем любой доступ к нему, _root_ все равно будет иметь к нему полный доступ. На этого пользователя просто не распространяется система прав доступа UNIX.
{% endcapture %}
<div class="notice--warning">{{ notice | markdownify }}</div> 

Есть еще одна причина, почему обычным пользователям не разрешается выполнять общесистемные действия. Такие действия несут потенциальную опасность. Обычные пользователи так ограничены, что любыми совими действиями они могут нарушить только свою собственную работу. На работу системы в целом они повлиять никак не могут. Суперпользователь _root_ же напротив, может легко "сломать" всю систему целиком. Это особенно актуально сейчас, в эру персональных компьютеров. Не все владельцы ПК являются профессиональными системными администраторами. Поэтому лучше для обычных дел - редактирования файлов, использования браузера, и подобных - использовать учетную запись обычного пользователя. 

Но выполнять настроечные, общесистемные действия все равно приходится регулярно и довольно часто. Каждый раз выходить их сеанса (то есть закрывать все запущенные процессы) и входить в сеанс рута, а потом обратно, очень неудобно. Для ускорения процесса есть две команды - _sudo_ и _sudo su_. Команда _sudo_ позволяет выполнить любую другую команду терминала с правами рута. Естественно, для этого нужно знать пароль рута. Так что система разделения прав доступа здесь не нарушается. Синтаксис команды _sudo_ очень простой:

```bash
$ sudo <команда>
```

Команда _sudo su_ позволяет временно (без выхода из сеанса) перети в сеанс рута. Она полезна, если нужно от имени суперпользователя выполнить сразу много команд и неудобно перед каждой писать "sudo". 

Этими командами надо пользоваться с осторожностью, так как они потенциально могут нарушить работу системы. Особенно аккуратно надо быть с командами, которые вы нашли в интернете для решения какой-то проблемы. Ведь они могут быть вредны (сознательно, а чаще несознательно). Желательно все-таки хотя бы в общих чертах понимать, что вы делаете, как работают те или иные команды и какие последствия будут от их применения. Если бездумно применять нагугленные команды рано или поздно вы обрушите все систему до состояния, когда восстановить ничего уже будет нельзя (и поверьте, любой системный администратор был в такой ситуации хотя бы однажды). Да и о работе системы ничего полезного не узнаете.

{% capture notice %}
Обращаем внимание! Никогда не работайте постоянно под учетной запись _root_. Это очень опасно. Даже опытные администраторы предпочитают пользоваться командой _sudo_. От ошибок никто не застрахован, но работа в учетке обычного пользователя и регулярные бекапы могут свести последствия к минимуму.
{% endcapture %}
<div class="notice--danger">{{ notice | markdownify }}</div>

{% capture notice-2 %}
Выводы:
1. Обычные пользовательские учетные записи сильно ограничены в правах.
1. Иногда необходимо произвести действия, оказывающие влияние на всю систему.
1. Для этого есть специальная учетная запись суперпользователя - root.
1. Во всех Linux-системах существует пользователь root с идентификатором 0.
1. Именно под учетной записью суперпользователя нужно выполнять общесистемные действия: настройка, установка и удаление программ, добавление пользователей.
1. Постоянно работать под учетной записью root категорически не рекомендуется, лучше иметь обычную учетку.
1. Чтобы каждый раз не перелогиниваться для выполнения администраторских команд, есть специальная команда sudo.
1. Командой sudo надо пользоваться с осторожностью, так как такие команды могут повредить работу операционной системы.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Какие основные действия с пользователями и группами?

![Файл /etc/group](/assets/images/os_text/os13-3.png "Файл /etc/group"){: .align-center style="width: 800px;"}
{: style="text-align: center; font-size:0.7em;"}

Теперь, когда мы познакомились с основными механизмами учетных записей пользователей, необходимо узнать, как совершать те или иные операции с пользователями. Надо сказать, что вся информация о пользователях и группах хранится в конфигурационных файлах (_/etc/passwd_, _/etc/shadow_, _/etc/group_). Это не просто информационные файлы, это и есть сама конфигурация. Поэтому необходимую настройку можно делать непосредственно изменяя эти файлы. Но это неудобно и чревато ошибками. Ведь если вы нарушите синтаксис этих файлов, это может сломать всю систему.

Поэтому в составе дистрибутивов существуют служебные программы, которые автоматизируют и облегчают основные настроечные действия. В этом разделе мы рассмотрим только самые основные, которые чаще всего приходится совершать. Остальные команды и действия можно найти в соответствующих справочниках и документации.

Команда _useradd_ позволяет добавить нового пользователя в систему. У нее есть один обязательный аргумент - имя нового пользователя.

```bash
sudo useradd test_user
```

Обратите внимание, что это действие - добавление пользователя - является общесистемным, поэтому может быть выполнено только администратором системы, то есть пользователем _root_. Здесь и далее мы будем обозначать это в командной строке использованием команды _sudo_. Если попытаться выполнить такую команду простым пользователем, вы получите ошибку _Permission denied_.

Команда _useradd_ только лишь добавляет учетную запись пользователя без какой-либо другой информации. Сразу пользоваться этой новой учеткой будет нельзя - ведь у нового пользователя не установлен пароль. Установить или изменить пароль пользователя можно командой _passwd_:

```bash
passwd test_user
```

При выполнении этой команды вам будет предложено ввести новый пароль пользователя два раза - для надежности. А если пароль уже существовал, тогда еще придется ввести старый пароль. Обратите внимание, на этот раз команда _sudo_ не обязательна - ведь пользователь может использовать команду _passwd_ для изменения собственного пароля. Изменить пароль других пользователей, конечно, нельзя. А вот _root_ может менять пароли любых пользователей.

Кроме имени пользователя и пароля у учетной записи есть еще много информации. Существует команда _adduser_, которая позволяет создать нового пользователя и сразу задать ему основную информацию, и парль в том числе:

```bash
sudo adduser test_user
	Adding user `test_user' ...
	Adding new group `test_user' (1001) ...
	Adding new user `test_user' (1001) with group `test_user' ...
	New password: 
	Retype new password: 
	passwd: password updated successfully
	Changing the user information for test
	Enter the new value, or press ENTER for the default
		Full Name []: 
		Room Number []: 
		Work Phone []: 
		Home Phone []: 
		Other []: 
	Is the information correct? [Y/n] Y
```

На примере выше видно, какую информацию можно задать. Большая часть этих полей носит справочный характер и чаще всего не используется. Поэтому ее просто можно оставить пустой.

Если хочется изменить эту информацию для уже существующего пользователя, вам понадобится команда _usermod_:

```bash
sudo usermod test_user
```

У этой команды вообще много опций, которые позволят отдельно задать конкретные параметры пользователя. Полный список опций доступен в _man usermod_.

Удалить пользователя можно командой _userdel_ или _deluser_:

```bash
sudo userdel test_user
```

Существуют аналоги этих команд для создания, удаления и изменения групп - соответственно _groupadd_, _groupdel_ и _groupmod_. Рассматривать их подробно мы не будем.

Из операций с группами чаще вего используется добавление пользователя в группу. Это происходит при помощи уже известной команды _usermod_ с определенными опциями, которые стоит запомнить:

```bash
sudo usermod -a -G group_name user_name
```

{% capture notice-2 %}
Выводы:
1. Команда useradd регистрирует нового пользователя в систему и все.
2. Команда adduser более полная - создает пользователя, домашнюю папку, задает ему пароль.
3. Команда userdel позволяет удалить пользователя.
4. Команда passwd используется для изменения пароля пользователя. 
5. Пользователь может изменить свой пароль, суперпользователь может сменить пароль кому угодно.
6. Команда usermod может изменить параметры пользователя.
7. usermod -a -G добавляет пользователя в группу.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Что такое права доступа?

![Файл /etc/group](/assets/images/os_text/os13-5.png "Файл /etc/group"){: .align-center style="width: 800px;"}
{: style="text-align: center; font-size:0.7em;"}

Мы рассмотрели, как устроены пользователи и группы, но еще не касались вопроса, а как именно им распределяются права на совершение тех или иных операций. И для того, чтобы приступить к рассмотрению механизма прав доступа, нужно вспомнить кое-что о UNIX-подобных системах. В них все объекты операционной системы представляются в виде файлов. Обычные файлы (документы) - это файлы, директории - это файлы, устройства - это тоже файлы. 

Поэтому выполнение любых действий с операционной системой связано с доступом и выполнением определенных операций с какими-то файлами. Если пользователь хочет обменяться пакетами по сети, он должен получить доступ к файлу сетевого адаптера. Если он хочет изменить какую-то настройку, он должен изменить содержимое определенного конфигурационного файла. Если он хочет установить программу, он должен создать файлы в определенной директории (которая тоже файл). Поэтому чтобы ограничить возможные действия пользователя, достаточно ограничить ему доступ к определенным файлам.

{% capture notice %}
Здесь и далее под файлом (без уточнений) мы будем понимать файлы в самом широком смысле - как объекты UNIX, включая документы, ссылки, каталоги, сокеты, устройства и так далее.
{% endcapture %}
<div class="notice--danger">{{ notice | markdownify }}</div>

Каждый файл, существующий в UNIX-подобной операционной системе, имеет определенные внутренние атрибуты. В том числе у каждого файла есть пользователь, который считается его владельцем и группа, которая тоже считается его владельцем. Эти атрибуты устанавливаются при создании файла. Пользователем-владельцем файла является пользователь, который его создал (из-под чьей учетной записи произошло создание этого файла), а группой-владельцем записывается группа по умолчанию этого пользователя. Суперпользователь может изменить как пользователя так и группу-владельца файла, то есть "переписать" этот файл на другого пользователя и на другую группу. При этом, конечно, пользователь и группа, которые владеют файлом не обязаны соответствовать друг другу. Владелец может изменить, например, только группу-владельца файла.

Еще надо помнить, что любые действия в операционной системе совершаются только от имени какого-то зарегистрированного пользователя. Система не может что-то делать "сама". Любой процесс инициируется каким-то пользователем и совершается от его имени. Даже если пользователь запустил программу, она тоже будет совершаться от его имени. Поэтому хотя с файлами, по сути дела, взаимодействуют именно программы, мы говорим о правах доступа пользователей. Любая программа запущена с правами того пользователя, который ее запустил. Или с правами той программы, которая запустила эту.

При этом взаимодействовать с файлом может, конечно, не только владелец но и другие пользователи. Как раз при попытке получить доступ к файлу операционная система проверяет, что за пользователь пытается это сделать. Здесь есть три варианта. Если идентификатор пользователя совпадает с идентификатором пользователя-владельца данного файла, то операционная система считает, что к файлу получает доступ владелец. Еще может быть, что пользователь не является владельцем файла, но входит в группу-владельца этого файла. Это второй случай. Если же ни то, ни то условие не выполняется, то операционная система считает пользователя "другим" (other). То есть по отношению к любому конкретному файлу данный пользователь может быть владельцем, членом группы или другим.

Но что именно значит "взаимодействие" с файлом? Ведь пользователь может совершать с файлами множество разных действий - копирование, редактирование, переименование, удаление и так далее. Всех не перечислишь и не учтешь. Операционные системы, основанные на UNIX, распознают всего три типа элементарных действий с файлами - чтение, запись и выполнение. Чтение - это когда пользователь пытается получить доступ к содержанию файла, но не изменяет его. Запись - это когда пользователь редактирует содержание файла, полностью или частично - неважно. Исполнение - это выполнение содержимого файла как программы. Это последнее действие, конечно, имеет смысл только для исполняемых файлов, но существует для всех. Как показывает практика, этих трех базовых действий вполне достаточно, они как кирпичики составляют все наше взаимодействие с операционной системой.

Таким образом, любой пользователь может иметь или не иметь право на чтение запись и выполнение определенного файла. В самом файле эти права фиксируются для трех уже знакомых категорий пользователей - владельца файла, членов группы-владельца файла и для всех остальных. Так что когда пользователь взаимодействует с файлом, система сначала устанавливает его роль по отношению к файлу - владелец, член группы или другой - а потом проверяет, какое действие пользователь пытается совершить. Если файл разрешает это действие данной категории пользователей - все хорошо, операционная система совершает это действие. Если не разрешено, то операционная система выдает ошибку _Permission denied_ - запрещено.

{% capture notice %}
Да, теоретически можно иметь доступ на запись к файлу без доступа на чтение. Тогда вы сможете перезаписать файл целиком, но не сможете увидеть, что там было или есть. На практике, конечно, такая комбинация практически не используется, но теоретически возможна.
{% endcapture %}
<div class="notice--warning">{{ notice | markdownify }}</div>

Каждое элементарное право доступа может быть либо установлено либо нет. То есть занимает ровно один бит. Три базовых права доступа для трех категорий пользователей дает нам девять бит прав доступа - чуть больше байта. Эти девять бит вы можете увидеть в выводе команды _ls -l_. В первом столбце мы видим десять символов. Первый - это тип файла. А следующие девять - как раз права доступа в формате _rwxrwxrwx_. R (read) - это право на чтение. W (write) - запись. X (execute) - право на выполнение. Первая тройка задает права владельца файла, вторая - членов группы, а третья - для всех остальных. Если на соответствующем месте стоит буква, значит право есть, а если прочерк (дефис) - права нет. Это, кстати, значит, что владелец не обязательно имеет полный доступ к файлу, он может сам себя ограничить. 

А что с другими действиями с файлами - копированием, перемещением, удалением и так далее? Разве они не учитываются операционной системой? На самом деле учитывается все, но не всегда так, как ожидается. Например, права доступа _rwx_ имеют особое значение для каталогов. Если вспомнить, что каталог - это просто файл со списком других файлов, то все становится просто. Право на чтение каталога - это право просматривать его содержимое, то есть список файлов в нем. Право на запись - это право на изменение этого списка - создание, переименование и перемещение файлов в нем. А вот право на исполнение - особое. Это право делать этот каталог текущим, то есть переходить в него.

Получается, что операционная система учитывает любые действия пользователя. Только некоторые не являются элементарными. Например, чтобы иметь возможность скопировать файл в другую директорию, вы должны иметь право на чтения данного файла, директории, в которой он лежит и право на запись в той директории, куда вы его копируете. Чтобы переместить файл, вам нужно право на запись и исходной и в конечной директории (а вот прао на чтение файла не обязательно).

Сами права доступа, кстати, доступны всем, кто может просмотреть список файлов директории, то есть для просмотра прав доступа к файлу надо иметь право на чтение директории, в которой он лежит.

{% capture notice-2 %}
Выводы:
1. Любые действия в системе совершаются от имени какого-то пользователя.
1. У каждого файла есть владелец и группа-владелец, которые задаются при создании файла.
2. По отношению к файлу пользователь может быть владельцем, членом группы или никем.
3. Права доступа к файлу задаются для каждой из этих трех категории пользователей.
4. Существует три базовых права доступа - на чтение, запись и выполнение.
5. Девять базовых прав доступа отображаются в атрибутах файла командой _ls -l_.
6. Для каталогов права доступа имеют свой смысл: чтение списка файлов, создание и удаление файлов и переход в эту папку соответственно.
1. Суперпользователь всегда имеет все права - они для него просто не проверяются.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Как задавать права доступа?

Кончено, при работе с операционной системой приходится постоянно иметь в виду систему прав доступа. Мы уже знаем, как посмотреть права доступа к файлу. Теперь познакомимся с основными действиями, которые можно сделать из командной строки по отношению к файлам, его владельцам и правам доступа.

Одно из самых распространенных действий - смена владельца или группы файла. Для этого существует команда _chown_. Вот ее общий синтаксис:

```bash
sudo chown new_owner:new_group file1 file2 …
```

После команды указывается новый владелец (имя, не идентификатор) и новая группа владелец файла. Можно изменить владельцев сразу у нескольких файлов, можно сделать это рекурсивно по директории. Также можно отдельно задавать только владельца файла:

```bash
sudo chown new_owner file1
```

Или только группу файла:

```bash
sudo chown :new_group file1
```

Обратите внимание, что сменить владельцев файла может только суперпользователь.

Но самая популярна операция - смена самих прав доступа. При работе с операционной системой постоянно приходится кому-то что-то разрешать или запрещать делать. Для изменения прав доступа служит команда _chmod_. С помощью нее мы может добавить, удалить какие-то отдельные права или переписать права полностью.

Для того, чтобы научиться менять права доступа, надо вспомнить внезапно восьмеричную систему счисления. Дело в том, что права доступа могут обозначаться двумя способами. Первый - уже знакомыми символами _rwx_. Мы можем написать команду, например, так:

```bash
chmod +x file_name
```

Это действие разрешит выполнение данного файла всеми пользователями (то есть установит соответствующий бит для всех трех категорий пользователей). А что делать, если нужно установить только для определенных категорий? Для этого есть специальные обозначения категорий - u (user, владелец файла), g (group, члены группы-владельца), o (other, все остальные пользователи). Поэтому мы можем написать, например так:

```bash
chmod u+x file_name
```

что разрешит выполнение только владельцу. Или так:

```bash
chmod ug+x file_name
```

что разрешит выполнение владельцу и членам группы. Конечно это можно делать с любыми правами, не только _x_. 

А вот как можно удалить какое-нибудь право:

```bash
chmod go-w file_name
```

Эта команда запретит изменение файла всем, кроме владельца.

Но иногда такая схема не очень удобна. Что если мы хотим полностью переопределить права доступа, и не хотим высчитывать, что нужно установить, а что удалить. Для этого существует вторая - восьмеричная запись прав доступа. Дело в том, что три бита прав для определенной категории пользователей представляют собой восьмеричное число - то есть цифру от 0 до 8. И каждая такая цифра определяет свой набор прав доступа. Для того, чтобы понять эту систему, достаточно познакомиться с такой таблицей:

{% capture block %}
|OCT|BIN|Mask|Права на файл|Права на каталог|
|---|---|----|-------------|----------------|
|0|000|- - -|отсутствие прав|отсутствие прав|
|1|001|- - x|запуск на выполнение|доступ к файлам и их атрибутам|
|2|010|- w -|изменение содержимого|создание и удаление файлов|
|3|011|- w x|права на запись и выполнение|все, кроме доступа к именам файлов|
|4|100|r - -|чтение содержимого|только чтение имен файлов|
|5|101|r - x|права на чтение и выполнение|чтение имен файлов и доступ файлам и их атрибутам|
|6|110|r w -|права на чтение и запись|только чтение имен файлов|
|7|111|r w x|полные права|все права|
{% endcapture %}
<div class="presentation">{{ block | markdownify }}</div>

Права для трех категорий задаются, соответственно, тремя восьмеричными числами. Так, например, 777 - это полные права для всех. 700 - это полные права для владельца и отсутствие прав для остальных. 640 - это права на чтение и изменение для владельца, только на чтение для группы и никаких прав для остальных.

На первый взгляд кажется сложным, но довольно быстро запоминается, а такую табличку легко нагуглить, если она забылась. Но такая форма позволяет очень быстро и компактно записать полный набор прав доступа к файлу или директории.

И эту восьмеричную запись также можно использовать в команде _chmod_:

```bash
chmod 640 file_name
```

Такая команда полностью переопределяет все права доступа, неважно, какие они были раньше.

Но иногда вы можете встретить запись прав доступа, состоящую не из трех, а из четырех цифр. Например, так: 0777. Эта более полная форма прав доступа. Дело в том, что помимо девяти основных прав есть еще три специальных бита прав доступа. Именно они и кодируются первой цифрой в четырехзначном обозначении. 

Первый из них - Setuid или SUID бит. Если он установлен, то пари запуске данного файла на исполнение он будет запущен с правами своего владельца, а не того пользователя, который его запустил. Такой бит используется, например, в команде sudo. Подумайте, почему этой команде нужен SUID и почему без него она не будет работать. Если вы посмотрите на ее права, то увидите строку _rwsr-xr-x_. Вот эта _s_ на месте права на выполнение и есть SUID-бит. Установить его можно такой командой:

```bash
chmod u+s file_name
```

Следующий специальный бит - Setgid или SGID-бит. Он также работает только с исполняемыми файлами, но файл будет запускаться с правами группы-владельца файла, а не с правами группы пользователя, который его запустил. Этот бит используется гораздо реже. Например, в программе _crontab_ права выглядят так: _rwxr-sr-x_. Обратите внимание на _s_ в правах группы. Установить SGID можно командой:

```bash
chmod g+s file_name
```

И, наконец, Sticky-bit. Это право доступа используется для директорий. Если установлен этот бит, то удалить файл из папки сможет только владелец файла, а не тот, у кого есть право на запись в этой папке. Это полезно для организации коллективных хранилищ, в которых создавать файлы может любой пользователь, а удалять - только тот, кто создал. Например, так работает системная папка _/tmp/_. Так выглядят ее права: _rwxrwxrwt_. последний символ _t_ - это и есть индикация Sticky-bit. Установить его можно так:

```bash
chmod +t file_name
```

А откуда берутся права только что созданных файлов? Для этого в системе действует так называемая маска. Базовые права (то есть права по умолчанию) для директорий равны 0777, то есть полные права для всех, а для файлов - 0666, то есть доступ всем на чтение и запись. Но из этих базовых прав вычитается значение, заданное в конфигурации для каждого пользователя. Это значение называется umask - пользовательская маска. Она обычно равна 0002 или 0022. Узнать ее текущее значение можно командой _umask_ без параметров:

```bash
umask
	0002
```

В нашем примере маска равна 0002. То есть директории будут создаваться с правами 0775 (_rwxrwxr-x_), а файлы - 0664 (_rw-rw-r--_).

Маска нужна исключительно для удобства. Она задает права по умолчанию при создании новых файлов. Изменить маску можно той же командой, но с параметром:

```bash
umask 0022
```

{% capture notice-2 %}
Выводы:
1. Можно изменить владельца и группу файла командой chown.
3. Права доступа к файлу может изменить владелец или рут командой chmod.
4. Права доступа задаются в символьном или в восьмеричном выражении.
5. Можно задать специальные биты прав доступа - SUID, SGID и Sticky-bit.
1. Новые файлы получают стандартные права доступа, заданные командой umask.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>